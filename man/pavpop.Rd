% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/pavpop.R
\name{pavpop}
\alias{pavpop}
\title{Estimate parameters and predict warps for curve data}
\usage{
pavpop(y, t, basis_fct, warp_fct, amp_cov, warp_cov, iter = c(5, 5),
  use_warp_gradient = FALSE, homeomorphisms = "no",
  like_optim_control = list())
}
\arguments{
\item{y}{list of \eqn{n} functional observations. Missing values are allowed.}

\item{t}{list of time points corresponding to y. Should be scaled to have outer endpoints at 0 and 1.}

\item{basis_fct}{basis function to describe the mean function.}

\item{iter}{two-dimensional numeric consisting of number of outer and inner iterations.}

\item{use_warp_gradient}{logical. Should warp prediction use the exact gradient for based optimization?}

\item{homeomorphisms}{should warps be constrained to be homeomorphisms? Options are: \code{'no'}, \code{'soft'} or \code{'hard'}. 'soft' will project the prediction onto the space of homeomorphisms after each prediction. 'hard' will do the optimiziation in the constrained space (not implemented yet!).}

\item{like_optim_control}{list of control options for likelihood optimization. Parameters are given as \code{c(amp_cov_par, warp_cov_par)} and options include lower, upper, method, ndev (see \code{\link[stats::optim]{optim}}).}

\item{amp_cov_par}{amplitude covariance parameters.}

\item{amp_cov_fct}{amplitude covariance matrix function.}

\item{warp_cov_par}{warp covariance parameters.}

\item{warp_cov_fct}{warp covariance matrix function.}

\item{tw}{anchor points for the warping parameters.}

\item{smooth_warp}{logical. Should warping functions be based on a monotonic cubic spline?}

\item{n_cores}{number of cores to use.}
}
\description{
This function does likelihood estimation in the model \deqn{y_i(t)=\theta(v(t, w_i))+x_i(t)+\epsilon_i(t)} based on iterative local linearization of the model around predictions of the random warping parameters \eqn{w_i}.
}
\examples{
# Load female growth data from the Berkeley growth study
t_orig <- fda::growth$age
y <- fda::growth$hgtf
m <- nrow(y)
n <- ncol(y)

# Specify age rage for normalization, endpoints are 0 and 1 in normalized data
t_range <- c(0, 20)
t <- replicate(n, t_orig / t_range[2], simplify = FALSE)
y <- lapply(1:n, function (x) y[, x])

# Set up basis function
kts <- seq(0, 1, length = 16)[1:15]
basis_fct <- make_basis_fct(kts = kts, intercept = TRUE, increasing = TRUE,
                            order = 3, boundary = c(0, 1))

# Set up covariance functions
warp_cov_par <- c(tau = 1)
warp_cov_fct <- make_cov_fct(Brownian, noise = FALSE, type = 'bridge')

amp_cov_par <- c(scale = 50, range = 1, smoothness = 1.5)
amp_cov_fct <- make_cov_fct(Matern, noise = TRUE)

# Set up parametrization
tw <- seq(0, 1, length = 5)[2:4]

# Estimate in the model

# Bounds of parameters
# NOTE: Prediction of velocities is only meaningful
#       when the smoothness parameter is > 0.5
lower <- c(1e-2, 1e-2, 0.5001, 1e-2)
upper <- c(200, 1, 3, 1)

res <- pavpop(y, t, basis_fct, amp_cov_par, amp_cov_fct,
              warp_cov_par, warp_cov_fct, tw, iter = c(3, 3),
              smooth_warp = TRUE, homeomorphism = 'soft',
              like_optim_control = list(lower = lower, upper = upper))

# Plot results
t_p <- seq(range(t)[1], range(t)[2], length = 100)
t_p_orig <- t_p * 20

# Functional fixed effect
theta <- basis_fct(t_p) \%*\% res$c

# Display data with predictions
plot(t_p_orig, theta, ylim = range(y), type = 'n', main = 'Original heights and predicted',
     xlab = 'Age', ylab = 'Height')
for (i in 1:n) {
  points(t_orig, y[[i]], pch = 19, cex = 0.3, col = rainbow(n)[i])
  lines(t_p_orig, predict_curve(t_p, t[[i]], y[[i]], res$c, basis_fct, amp_cov_fct, res$amp_cov_par,
                                res$w[,i], tw),
        lwd = 0.5, col = rainbow(n)[i])
}
lines(t_p_orig, theta, ylim = range(y), lwd = 2, lty = 2,)

# Compute and display growth velocities
plot(t_p_orig, t_p_orig, ylim = c(0, 23), type = 'n', main = 'Predicted growth velocities',
     xlab = 'Age', ylab = 'Growth velocity')
for (i in 1:n) {
  lines(t_p_orig, predict_curve(t_p, t[[i]], y[[i]], res$c, basis_fct, amp_cov_fct, res$amp_cov_par,
                                res$w[,i], tw, deriv = TRUE) / t_range[2],
        lwd = 0.5, col = rainbow(n)[i])
}


# Display predicted warping functions
plot(t_orig, t_orig, type = 'l', lwd = 2, lty = 2, main = 'Warping functions', xlab = 'Age', ylab = 'Biological age')
for (i in 1:n) lines(t_orig, t_range[2] * v(res$w[,i], t[[i]], tw, smooth = TRUE), lwd = 0.2)
}
\keyword{estimation}
\keyword{likelihood}

